{"version":3,"file":"lottie-interactivity.es.js","sources":["../src/main.js"],"sourcesContent":["const DEFAULT_OPTIONS = {\n  player: 'lottie-player',\n};\nconst LOTTIE_PLAYER_NODE = 'LOTTIE-PLAYER';\nconst ERROR_PREFIX = '[lottieInteractivity]:';\n\n/**\n * LottieFiles interactivity for Lottie\n */\nexport class LottieInteractivity {\n  constructor({ actions, container, mode, player, ...options } = DEFAULT_OPTIONS) {\n    // Resolve lottie instance specified in player option\n    if (!(typeof player === 'object' && player.constructor.name === 'AnimationItem')) {\n      if (typeof player === 'string') {\n        const elem = document.querySelector(player);\n\n        if (elem && elem.nodeName === LOTTIE_PLAYER_NODE) {\n          player = elem.getLottie();\n        }\n      } else if (player instanceof HTMLElement && player.nodeName === LOTTIE_PLAYER_NODE) {\n        player = player.getLottie();\n      }\n\n      // Throw error no player instance has been successfully resolved\n      if (!player) {\n        throw new Error(`${ERROR_PREFIX} Specified player is invalid.`, player);\n      }\n    }\n\n    // Get the configured container element.\n    if (typeof container === 'string') {\n      container = document.querySelector(container);\n    }\n\n    // Use player wrapper as fallback if container couldn't be resolved.\n    if (!container) {\n      container = player.wrapper;\n    }\n\n    this.player = player;\n    this.container = container;\n    this.mode = mode;\n    this.actions = actions;\n    this.options = options;\n  }\n\n  getContainerVisibility() {\n    // Get the bounding box for the lottie player or container\n    const { top, height } = this.container.getBoundingClientRect();\n\n    // Calculate current view percentage\n    const current = window.innerHeight - top;\n    const max = window.innerHeight + height;\n    return current / max;\n  }\n\n  getContainerCursorPosition(cursorX, cursorY) {\n    const { top, left, width, height } = this.container.getBoundingClientRect();\n\n    const x = ((cursorX - left) / width);\n    const y = ((cursorY - top) / height);\n\n    return { x, y };\n  }\n\n  start() {\n    // Configure player for start\n    this.player.loop = true;\n    this.player.stop();\n\n    if (this.mode === 'scroll') {\n      // this.#scrollHandler();\n\n      window.addEventListener('scroll', this.#scrollHandler);\n    }\n\n    if (this.mode === 'cursor') {\n      // this.#cursorHandler(-1, -1);\n\n      this.container.addEventListener('mousemove', this.#mousemoveHandler);\n      this.container.addEventListener('mouseout', this.#mouseoutHandler);\n    }\n  }\n\n  stop() {\n    if (this.mode === 'scroll') {\n      window.removeEventListener('scroll', this.#scrollHandler);\n    }\n\n    if (this.mode === 'cursor') {\n      this.container.addEventListener('mousemove', this.#mousemoveHandler);\n      this.container.addEventListener('mouseout', this.#mouseoutHandler);\n    }\n  }\n\n  #mousemoveHandler = (e) => {\n    this.#cursorHandler(e.clientX, e.clientY);\n  }\n\n  #mouseoutHandler = () => {\n    this.#cursorHandler(-1, -1);\n  }\n\n  #cursorHandler = (x, y) => {\n    // Resolve cursor position if cursor is inside container\n    if (x !== -1 && y !== -1) {\n      // Get container cursor position\n      const pos = this.getContainerCursorPosition(x, y);\n\n      // Use the resolved position\n      x = pos.x;\n      y = pos.y;\n    }\n\n    // Find the first action that satisfies the current position conditions\n    const action = this.actions.find(\n      ({ position }) => {\n        if (Array.isArray(position.x) && Array.isArray(position.y)) {\n          return x >= position.x[0] && x <= position.x[1] && y >= position.y[0] && y <= position.y[1];\n        } else if (!Number.isNaN(position.x) && !Number.isNaN(position.y)) {\n          return x === position.x && y === position.y;\n        }\n\n        return false;\n      },\n    );\n\n    // Skip if no matching action was found!\n    if (!action) {\n      return;\n    }\n\n    // Process action types:\n    if (action.type === 'seek') {\n      // Seek: Go to a frame based on player scroll position action\n      const xPercent = (x - action.position.x[0]) / (action.position.x[1] - action.position.x[0]);\n      const yPercent = (y - action.position.y[0]) / (action.position.y[1] - action.position.y[0]);\n\n      this.player.playSegments(action.frames, true);\n      this.player.goToAndStop(Math.ceil(((xPercent + yPercent) / 2) * this.player.totalFrames), true);\n    } else if (action.type === 'loop') {\n      this.player.playSegments(action.frames, true);\n    } else if (action.type === 'play') {\n      // Play: Reset segments and continue playing full animation from current position\n      if (this.player.isPaused === true) {\n        this.player.resetSegments();\n      }\n      this.player.playSegments(action.frames);\n    } else if (action.type === 'stop') {\n      // Stop: Stop playback\n      this.player.goToAndStop(action.frames[0], true);\n    }\n  };\n\n  #scrollHandler = () => {\n    // Get container visibility percentage\n    const currentPercent = this.getContainerVisibility();\n\n    // Find the first action that satisfies the current position conditions\n    const action = this.actions.find(\n      ({ visibility }) => currentPercent >= visibility[0] && currentPercent <= visibility[1],\n    );\n\n    // Skip if no matching action was found!\n    if (!action) {\n      return;\n    }\n\n    // Process action types:\n    if (action.type === 'seek') {\n      // Seek: Go to a frame based on player scroll position action\n      this.player.playSegments(action.frames, true);\n      this.player.goToAndStop(\n        Math.ceil(\n          ((currentPercent - action.visibility[0]) / (action.visibility[1] - action.visibility[0])) *\n            this.player.totalFrames,\n        ),\n        true,\n      );\n    } else if (action.type === 'loop') {\n      // Loop: Loop a given frames\n      this.player.playSegments(action.frames, true);\n    } else if (action.type === 'play') {\n      // Play: Reset segments and continue playing full animation from current position\n      if (this.player.isPaused === true) {\n        this.player.resetSegments();\n        this.player.play();\n      }\n    } else if (action.type === 'stop') {\n      // Stop: Stop playback\n      this.player.goToAndStop(action.frames[0], true);\n    }\n  };\n}\n\nexport const create = options => {\n  const instance = new LottieInteractivity(options);\n  instance.start();\n\n  return instance;\n};\n\nexport default create;\n"],"names":["DEFAULT_OPTIONS","player","LottieInteractivity","actions","container","mode","options","e","_this","clientX","clientY","x","y","pos","getContainerCursorPosition","action","find","position","Array","isArray","Number","isNaN","type","xPercent","yPercent","playSegments","frames","goToAndStop","Math","ceil","totalFrames","isPaused","resetSegments","currentPercent","getContainerVisibility","visibility","play","_typeof","constructor","name","elem","document","querySelector","nodeName","getLottie","HTMLElement","Error","wrapper","this","getBoundingClientRect","top","height","window","innerHeight","cursorX","cursorY","left","width","loop","stop","addEventListener","removeEventListener","create","instance","start"],"mappings":"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"}